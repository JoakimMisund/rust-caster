extern crate chromecast_link;

use chromecast_link::Chromecast;

use std::io;

use chromecast_link::message_manager::MessageManager;
use chromecast_link::cast::requests;
use chromecast_link::cast::cast_channel::*;
use chromecast_link::channels::heartbeat;
use chromecast_link::channels::receiver;

const DEFAULT_SOURCE_ID: &'static str = "sender-0";
const DEFAULT_DESTINATION_ID: &'static str = "receiver-0";

const NS_HEARTBEAT: &'static str = "urn:x-cast:com.google.cast.tp.heartbeat";
const NS_RECEIVER: &'static str = "urn:x-cast:com.google.cast.receiver";
const NS_MEDIA: &'static str = "urn:x-cast:com.google.cast.media";

const MESSAGE_TYPE_RECEIVER_STATUS: &'static str = "RECEIVER_STATUS";
const MESSAGE_TYPE_LAUNCH_ERROR: &'static str = "LAUNCH_ERROR";
const MESSAGE_TYPE_LOAD: &'static str = "LOAD";

const STREAM_TYPE_UNKNOWN: &'static str = "UNKNOWN";
const STREAM_TYPE_BUFFERED: &'static str = "BUFFERED";
const STREAM_TYPE_LIVE: &'static str = "LIVE";

const APP_BACKDROP: &'static str = "E8C28D3C";
const APP_YOUTUBE: &'static str = "YouTube";
const APP_MEDIA_RECEIVER: &'static str = "CC1AD845";

fn get_play_media_message(session_id: &str,
                          destination: &str,
                          url: &str,
                          content_type: &str)
                          -> CastMessage {
    MessageManager::create(NS_MEDIA.to_owned(),
                           DEFAULT_SOURCE_ID.to_owned(),
                           destination.to_owned(),
                           Some(requests::MediaRequest {
                               request_id: 2,
                               session_id: session_id.to_owned(),
                               typ: MESSAGE_TYPE_LOAD.to_owned(),

                               media: requests::Media {
                                   content_id: url.to_owned(),
                                   stream_type: STREAM_TYPE_BUFFERED.to_owned(),
                                   content_type: content_type.to_owned(),
                               },

                               current_time: 0_f64,
                               autoplay: true,
                               custom_data: requests::CustomData::new(),
                           }))
}

fn send_message(chromecast: &Chromecast, message: CastMessage) {
    if let Some(stream_rc) = chromecast.stream.as_ref() {
        MessageManager::send(&mut *stream_rc.borrow_mut(), message);
    } else {
        panic!("Can't get stream to write message!");
    }
}

fn receive_message(chromecast: &Chromecast) -> CastMessage {
    if let Some(stream_rc) = chromecast.stream.as_ref() {
        MessageManager::receive(&mut *stream_rc.borrow_mut())
    } else {
        panic!("Can't get stream to write message!");
    }
}

fn main() {
    let mut chromecast = Chromecast::new("az_chromecast.local".to_owned(), 8009);

    if let Err(err) = chromecast.connect() {
        panic!("Chromecast is unable to establish connection: {:?}", err);
    }

    let heartbeat_channel = chromecast.create_heartbeat_channel();
    let connection_channel = chromecast.create_connection_channel();
    let receiver_channel = chromecast.create_receiver_channel();

    let mut media_loaded = false;

    connection_channel.connect(DEFAULT_DESTINATION_ID.to_owned());
    heartbeat_channel.ping();
    receiver_channel.launch_app(APP_MEDIA_RECEIVER.to_owned());

    loop {
        let message = chromecast.receive();

        if let Ok(payload) = heartbeat_channel.try_handle(&message) {
            if payload.typ == "PING" {
                heartbeat_channel.pong();
            }
        } else if let Ok(payload) = connection_channel.try_handle(&message) {
            println!("Connection channel message received: {:?}", payload);
        } else if let Ok(payload) = receiver_channel.try_handle(&message) {
            match payload {
                receiver::Reply::Status(reply) => {
                    if reply.status.applications.len() > 0 && !media_loaded {
                        let application = &reply.status.applications[0];

                        // Connect to application.
                        connection_channel.connect(application.transport_id.clone());

                        println!("Connected to {}", application.transport_id);

                        let media_channel = chromecast.create_media_channel(
                            application.transport_id.clone(),
                            application.session_id.clone()
                        );

                        media_channel.load(
                            "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4".to_owned(),
                            "video/mp4".to_owned());

                        media_loaded = true;
                    }
                }
                _ => {
                    println!("Receiver channel message received: {:?}", payload);
                }
            }
        }
    }

    // chromecast.receiver.listen(|message, payload| {
    //
    // });
    //
    // chromecast.listen();
    //
    // loop {
    // let (message, channel) = chromecast.listen();
    // }

    /*loop {
        let message = receive_message(&chromecast);

        println!("---------------------\nReceived: {:?}", message);

        match message.get_namespace() {
            NS_RECEIVER => {
                let receiver_response: requests::ReceiverResponse =
                    MessageManager::parse_payload(&message);

                println!("---------------------\nPyaload {:?}", receiver_response);

                if receiver_response.status.applications.len() > 0 {
                    let application = &receiver_response.status.applications[0];

                    // Connect to application.
                    connection_channel.connect(application.transport_id.clone());

                    let video_url = "http://commondatastorage.googleapis.\
                                     com/gtv-videos-bucket/sample/BigBuckBunny.mp4";

                    // Ask application to load video.
                    let play_message = get_play_media_message(&application.session_id,
                                                              &application.transport_id,
                                                              video_url,
                                                              "video/mp4");
                    println!("---------------------\nPlay message {:?}", play_message);
                    send_message(&chromecast, play_message);
                }
            }
            NS_HEARTBEAT => {
                let heartbeat_payload: requests::GenericRequest =
                    MessageManager::parse_payload(&message);
                if heartbeat_payload.typ == "PING" {
                    heartbeat_channel.pong();
                }
            }
            _ => {}
        }
    }*/
}
